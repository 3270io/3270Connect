package main

import (
	"encoding/json"
	"fmt"
	"io/ioutil"
	"log"
	"os"
	"strconv"
	"time"

	"gitlab.jnnn.gs/jnnngs/go3270" // Replace with the actual import path
)

const maxRetries = 3
const retryInterval = 2 * time.Second

type Session struct {
	emulator *go3270.Emulator
}

type Config struct {
	Host       string `json:"host"`
	Port       string `json:"port"`
	ScriptPort string `json:"scriptPort"`
	Login      string `json:"login"`
	Password   string `json:"password"`
	Steps      []Step `json:"steps"`
}

type Step struct {
	Action  string `json:"action"`
	Message string `json:"message"`
	X       int    `json:"x"`
	Y       int    `json:"y"`
	Data    string `json:"data"`
}

func (s *Session) Disconnect() error {
	if s.emulator != nil {
		return s.emulator.Disconnect()
	}
	return nil
}

func main() {
	filename := "App_Functional_Test_Results_" + time.Now().Format("20060102-150405") + ".html"

	config, err := loadConfig("config.json")
	if err != nil {
		log.Fatalf("Error loading config: %s", err)
	}
	portInt, err := strconv.Atoi(config.Port)
	if err != nil {
		log.Fatalf("Error converting port to integer: %s", err)
	}
	emulator := go3270.NewEmulator(config.Host, portInt, config.ScriptPort)

	session, err := startScriptingSession(&emulator) // Use & to pass the address of emulator

	if err != nil {
		log.Fatalf("Error starting scripting session: %s", err)
	}
	defer session.Disconnect() // You should disconnect using session instead of emulator

	saveScreen(filename, session)

	for _, step := range config.Steps {
		log.Printf("Executing step: %s", step.Action)
		switch step.Action {
		case "string_found":
			verifyString(step.X, step.Y, step.Data, step.Message, session.emulator)
		case "fill_field":
			log.Printf("Filling field at X: %d, Y: %d with data: %s", step.X, step.Y, step.Data)
			fillField(session.emulator, step.X, step.Y, step.Data)
		case "send_enter":
			log.Println("Sending Enter key")
			sendEnter(session.emulator)
		case "clear":
			log.Println("Clearing screen")
			clearScreen(session.emulator)
			saveScreen(filename, session)
		case "wait":
			log.Printf("Waiting for %d seconds", step.X)
			time.Sleep(time.Duration(step.X) * time.Second)
		}
		session.emulator.SaveScreen(filename)
		log.Printf("Step completed: %s", step.Action)
	}

	appendToFile(filename, "</body></html>")
	log.Println("Script execution completed")
}

func loadConfig(filename string) (Config, error) {
	data, err := ioutil.ReadFile(filename)
	if err != nil {
		return Config{}, fmt.Errorf("Failed to read config file: %w", err)
	}

	var config Config
	if err := json.Unmarshal(data, &config); err != nil {
		return Config{}, fmt.Errorf("Failed to parse config file: %w", err)
	}

	return config, nil
}

func startScriptingSession(emulator *go3270.Emulator) (*Session, error) {
	session := &Session{}

	for i := 0; i < maxRetries; i++ {
		if err := emulator.Connect(); err != nil {
			log.Printf("Attempt %d: Failed to connect to emulator: %s", i+1, err)
			time.Sleep(2 * time.Second)
			continue
		}

		log.Printf("Attempt %d: Connection established", i+1)
		session.emulator = emulator
		return session, nil
	}

	return nil, fmt.Errorf("Failed to establish connection after multiple attempts")
}

func verifyString(x, y int, data, message string, emulator *go3270.Emulator) {
	value, err := emulator.GetValue(x, y, len(data))
	if err != nil {
		log.Fatalf("Failed to get value from screen: %s", err)
	}
	if value != data {
		log.Fatalf(message)
	}
}

func fillField(emulator *go3270.Emulator, x, y int, data string) {
	err := emulator.FillString(x, y, data)
	if err != nil {
		log.Fatalf("Failed to fill field: %s", err)
	}
}

func sendEnter(emulator *go3270.Emulator) {
	err := emulator.Press(go3270.Enter)
	if err != nil {
		log.Fatalf("Failed to send Enter key: %s", err)
	}
}

func clearScreen(emulator *go3270.Emulator) {
	err := emulator.ClearScreen()
	if err != nil {
		log.Fatalf("Failed to clear screen: %s", err)
	}
}

func saveScreen(filename string, session *Session) {
	err := session.emulator.SaveScreen(filename) // Fix this line
	if err != nil {
		log.Fatalf("Failed to save screen content to %s: %s", filename, err)
	}
}

func appendToFile(filename, content string) error {
	f, err := os.OpenFile(filename, os.O_APPEND|os.O_WRONLY, 0644)
	if err != nil {
		return fmt.Errorf("Failed to open file: %w", err)
	}
	defer f.Close()

	if _, err := f.WriteString(content); err != nil {
		return fmt.Errorf("Failed to write to file: %w", err)
	}

	return nil
}

func createInitialHTML(filename string) error {
	header := `<!DOCTYPE html>
<html>
<head>
    <meta charset='UTF-8'>
    <style>body { font-family: monospace; white-space: pre; }</style>
</head>
<body>
`
	err := ioutil.WriteFile(filename, []byte(header), 0644)
	if err != nil {
		return fmt.Errorf("Failed to create initial HTML: %w", err)
	}
	return nil
}

func buildHTMLFromScreen(screenContent string) string {
	// Instead of a full HTML document, just wrap each screen in a div for clarity.
	return "<div>" + screenContent + "</div><hr>"
}
